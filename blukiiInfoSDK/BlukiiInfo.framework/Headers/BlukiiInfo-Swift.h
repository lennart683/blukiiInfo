#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.0.1 effective-4.2 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// <h1>Main Controller class for discovering BLE modules and resolving blukii concerned data from the blukii Info Manager.</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE data and resolving data from blukii Info Manager (https://manager.blukiiinfo.com)
///   </li>
///   <li>
///     Resolving data for a single blukii module or tag from blukii Info Manager
///   </li>
///   <li>
///     Resolving news from blukii Info Manager
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules, extract their BLE data and resolve their data from blukii Info Manager</h2>
/// Use this feature to discover BLE modules in your environment and optionally retrieve corresponding data from blukii Info Manager.
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (delegate <code>onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
/// var mBlukiiClient: BKClient!
///
/// override func viewDidLoad() {
///     ...
///     mBlukiiClient = BKClient()
///     mBlukiiClient.discoveryDelegate = self
///     mBlukiiClient.initDiscovery()
///     ...
/// }
///
/// func onInitialized() {
///     if mBlukiiClient.startDiscovery() {
///         // Discovery successfully started
///     }
/// }
///
/// func onDiscoveryResult(discoveryResultList: [BlukiiInfo.BKOutputElement]) { }
/// func onDiscoveryError(errorCode: BlukiiInfo.BKClient.ErrorCode) { }
/// func onDiscoveryInfo(infoCode: BlukiiInfo.BKClient.InfoCode) { }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
/// func onInitialized() {
///       // Discovery successfully initialized
///
///       let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///       discoverySettings.setRssiThreshold(-100)
///       discoverySettings.scanDuration = 10000
///       ...
///
///       if mBlukiiClient.startDiscovery() {
///           // Discovery successfully started
///       }
///  }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_: )</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKClient.InfoCode.INFO_DISCOVERY_PAUSED</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the iBeacon Region 123456789AB-CDEF-01234-00000000002 or 123456789AB-CDEF-01234-00000000003. In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Configure resolver settings</h3>
/// Use the <code>BKResolveSettings</code>object for configuring the resolving of the blukii Info Manager data.
/// Call <code>BKClient.resolveSettings</code>to retrieve the settings property set.
/// <em>Note:</em> <code>BKResolveSettings.resolveEnabled</code> has to be set true to enable the resolver!
/// \code
/// func onInitialized() {
///       // Discovery successfully initialized
///
///       let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///       discoverySettings.setRssiThreshold(-100)
///       discoverySettings.scanDuration = 10000
///       ...
///       
///       // change resolver settings
///       let resolveSettings: BKResolveSettings = mBlukiiClient.resolveSettings
///       resolveSettings.resolveEnabled = true
///       resolveSettings.setLanguagePriority([BKResolveSettings.OutputLanguage.English, BKResolveSettings.OutputLanguage.German])
///       ...
///
///       if mBlukiiClient.startDiscovery() {
///           // Discovery successfully started
///       }
///  }
///
/// \endcode<h3>4. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
/// func onDiscoveryResult(discoveryResultList: [BKOutputElement]) {
///   // Discovery phase has finished: list of OutputElements are retrieved
///
///   for outputElement in discoveryResultList {
///      let id = outputElement.id
///      let rssi = outputElement.discoveryData?.rssi
///      ...
///   }
/// }
///
/// \endcode<h3>5. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(BKClient.ErrorCode)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(BKClient.InfoCode)</code> will be called if there is important information about the discover process.
/// \code
/// func onDiscoveryError(errorCode: BKClient.ErrorCode) {
///     // An error has been sent from discover
/// }
///
/// func onDiscoveryInfo(infoCode: BKClient.InfoCode) {
///     // An info has been sent from discovery
/// }
///
/// \endcode<h2>B. Resolve data for a single blukii module or tag from blukii Info Manager</h2>
/// Retrieve data for a module or tag from blukii Info Manager by calling <code>resolveInputElement(InputElement)</code>
/// You have to prepare an <code>BKInputElement</code> that stands for a blukii number, NFC tag or scan result. Please see <code>BKInputElement</code> for more Information.
/// If the resolving proccess is successfull the delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code> is called.
/// Otherwise the delegate <code>BKClientResolveDelegate.onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode)</code> lets you know the error of the resolving proccess.
/// \code
/// mBlukiiClient.resolveDelegate = self
///
/// func resolveSingleElement() {
///     // call resolver
///     let inputElement = BKInputElement(tagID: "", inputType: BKInputSourceType.NFC)
///     mBlukiiClient.resolveInputElement(inputElement)
/// }
///
/// func onResolveInputElementResult(outputElement: BKOutputElement) {
///     let id = outputElement.id
///     let url = outputElement.resolveData?.url
/// }
///
/// func onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode) {
///     // An error has been sent from resolver
/// }
///
/// \endcode<h2>C. Resolving news from blukii Info Manager</h2>
/// Retrieve a translated news text from the blukii Info Manager.
/// If the resolving process is successfull the delegate <code>BKClientNewsDelegate.onNewsResult(news: String)</code> is called.
/// Otherwise the delegate <code>BKClientNewsDelegate.onNewsError(errorCode: BKClient.ErrorCode)</code> lets you know the error of the resolving process.
/// \code
/// mBlukiiClient.newsDelegate = self
///
/// func resolveNews() {
///     mBlukiiClient.resolveServerNews("en-gb")
/// }
///
/// func onNewsResult(news: String) {
///     // news retrieved
/// }
///
/// func onNewsError(errorCode: BlukiiInfo.BKClient.ErrorCode) {
///     // An error has been sent from resolver
/// }
///
/// \endcode
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is a part of <code>BKOutputElement</code>
/// It will be set if the <code>BKOutputElement</code> is returned by the delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> after calling BKClient.initDiscovery(). For Other BKClient delegates BKDiscoveryData is <code>nil</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Data Object that defines the input data for resolving requests to blukii Info Manager (https://manager.blukiiinfo.com).
/// It is used in two cases:
/// <ul>
///   <li>
///     <em>Delegate</em> <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code>:
///   </li>
/// </ul>
/// <code>BKInputElement</code> is part of every <code>BKOutputElement</code>. It contains input type <code>BKInputSourceTpye.BLUKII</code> and the device name of the discovered BLE module.
/// <ul>
///   <li>
///     <em>Function</em> <code>BKClient.resolveInputElement(BKInputElement)</code>:
///   </li>
/// </ul>
/// <code>BKInputElement</code> is used as input property for a single recolving action. It has to be created by initializer <code>BKInputElement(String, BKInputSourceType)</code>.
/// If resolving is successful it will be unmodified part of <code>BKOutputElement</code> that is returned by delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code>
SWIFT_CLASS("_TtC10BlukiiInfo14BKInputElement")
@interface BKInputElement : NSObject <NSSecureCoding>
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class BKResolveData;

/// Read only data object for data of BLE discover and resolving process.
/// <code>BKOutputElement</code> is returned by delegates of the BKClient functions for discovery and resolve of BLE modules.
/// It is an combination of data that is encapsulated in specific data objects:
/// <ul>
///   <li>
///     <code>BKInputElement</code>: input data that is created by discovery process (blukii number) or external inputs (NFC tag id, scan of barcodes).
///     A cnversion of the <code>BKInputelement.tagID</code> is saved in <code>id</code>
///   </li>
///   <li>
///     <code>BKDiscoveryData</code>: emitted data of the BLE module
///   </li>
///   <li>
///     <code>BKResolveData</code>: resolved data requested from blukii Info Manager (https://manager.blukiiinfo.com)
///     The state of resolve process is saved by <code>resolveState</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC10BlukiiInfo15BKOutputElement")
@interface BKOutputElement : NSObject <NSSecureCoding>
/// The blukii number of the OutputElement
/// In Some cases it is a coversion of the input tag id (see <code>BKInputElement.tagID</code>)
/// If it is an iBeacon the id is <UUID><Major><Minor>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The resolved data from blukii Info Manager (https://manager.blukiiinfo.com)
/// For more information see <code>BKResolveData</code>
/// returns the data object of resolved data
@property (nonatomic, readonly, strong) BKResolveData * _Nullable resolveData;
/// The emitted BLE data of one module
/// For more information see BKDiscoveryData
/// returns data object of discovered BLE data
@property (nonatomic, readonly, strong) BKDiscoveryData * _Nullable discoveryData;
/// The input data (tag id and type)
/// For more Information see <code>BKInputElement</code>
/// returns data object of input data
@property (nonatomic, readonly, strong) BKInputElement * _Nullable inputElement;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class NSNumber;

/// Read only data object for resolved output data of the blukii info manager
/// <code>BKResolveData</code> can be valid for blukii modules only.
/// It contains the result of a data request to the blukii Info Manager (https://manager.blukiiinfo.com).
/// The <code>BKResolveData</code> fields contain the values of on corresponding blukii number.
/// <code>BKResolveData</code> is part of <code>BKOutputElement</code>
/// It will be set for the following cases:
/// <ul>
///   <li>
///     OutputElement ID (see <code>BKOutputElement.id</code>) must be configured as a blukii number on the blukii Info Manager by an Info Manger user. This is an requierement for all <code>BKClient</code> delegates!
///   </li>
///   <li>
///     <code>BKResolveData</code> will be requested during the discovery (see <code>BKClient.initDiscovery()</code>) for all discovered Elelements if the setting <code>BKResolveSettings.resolveEnabled</code> is set true. If some data is responded it will be returned as part of an <code>BKOutputElement</code> by delegate <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> The result state of resolving can additionally be read by calling <code>BKOuputElement.resolveState</code>:
///     <ul>
///       <li>
///         UNRESOLVED: Resolve is off (<code>BKResolveSettings.resolveEnabled</code> is false) or blukii Info Manager is not connectable
///       </li>
///       <li>
///         RESOLVED: blukii Info Manager has responded data for the OutputElement ID
///       </li>
///       <li>
///         NODATA: blukii Info Manager is connectable but has responded no data for the OutputElement ID
///       </li>
///       <li>
///         CACHED: ResolveData contains cached data that has been responded earlier (see cache settings on <code>BKResolveSettings</code>)
///       </li>
///     </ul>
///   </li>
///   <li>
///     <code>BKResolveData</code> will be requested for a single Element by calling (see <code>BKClient.resolveInputElement(BKInputElement)</code>). If some data is responded it will be returned as part of an <code>BKOutputElement</code> by delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code>. The result state of resolving can additionally be read by calling <code>BKOutputElement.resolveState</code>. For single element requests there is no cache available.
///     <ul>
///       <li>
///         RESOLVED: blukii Info Manager has responded data for the OutputElement ID
///       </li>
///       <li>
///         NODATA: blukii Info Manager has not responded data for the OutputElement ID
///       </li>
///     </ul>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC10BlukiiInfo13BKResolveData")
@interface BKResolveData : NSObject <NSSecureCoding>
/// The value of the language specific blukii number field <em>Title</em>
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> If the language specific field <em>Title</em> is not set <code>title</code> contains the value of field <em>Name</em> (as fallback)
/// Value of blukii number field <em>Title</em>
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The Value of the language specific blukii number field <em>URL</em>
/// The language is defined by property <code>language</code>
/// <em>Note:</em> In most cases getUrl returns an url to a OutputType specific file. Exceptions are:
/// <ul>
///   <li>
///     OutputType <code>BKOutputType.MESSAGE</code>: The message text itself will be returned.
///   </li>
///   <li>
///     Resolving single elements of <code>BKInputSourceType.SCAN</code> by <code>BlukiiClient.resolveInputElement(BKInputElement)</code>: If you resolve a QR code with format <code>BKOutputType.WIFI</code> or <code>BKOutputType.VCARD</code> the WIFI or VCARD formatted code will be returned.
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// The output language of the BKResolveData set.
/// It shows the language specific selection of the blukii number fields <code>url</code> and <code>title</code>, for <code>BKOutputType.PDF</code> also of <code>urlExtra</code> and <code>plainTextExtra</code>
/// The output language is chosen by the resolver process. If only one language specific blukii number URL and title is defined it will be returned. Otherwise the language is chosen according the language priority setting (see <code>BKResolveSettings.getLanguagePriority()</code>)
/// The value can be one of the following languages codes: en-gb, fr-fr or de-de
@property (nonatomic, readonly, copy) NSString * _Nullable language;
/// Preview Image from Backend
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable name;
@property (nonatomic, readonly, strong) NSNumber * _Nullable infoProviderId;
/// The value of the date where the blukii Number was resolved
///
/// returns:
/// NSDate object
@property (nonatomic, readonly, copy) NSDate * _Nonnull resolveDate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the resolving process of data from blukii Info Manager (https://manager.blukiiinfo.com)
/// You can access the BKResolveSettings by calling <code>BKClient.resolveSettings</code>
/// Every settings value is writeable and has a default value that is used if not changed by the developer.
/// With the exception of <code>getLanguagePriority()</code> the ResolveSettings properties are only affecting the discovery process that is started by <code>BKClient.initDiscovery()</code>
/// For the single resolving process that is started by <code>BKClient.resolveInputElement(input: BKInputElement)</code> only <code>getLanguagePriority()</code> is relevant.
SWIFT_CLASS("_TtC10BlukiiInfo17BKResolveSettings")
@interface BKResolveSettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7S__) && __ARM_ARCH_7S__
// Generated by Apple Swift version 5.0.1 effective-4.2 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// <h1>Main Controller class for discovering BLE modules and resolving blukii concerned data from the blukii Info Manager.</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE data and resolving data from blukii Info Manager (https://manager.blukiiinfo.com)
///   </li>
///   <li>
///     Resolving data for a single blukii module or tag from blukii Info Manager
///   </li>
///   <li>
///     Resolving news from blukii Info Manager
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules, extract their BLE data and resolve their data from blukii Info Manager</h2>
/// Use this feature to discover BLE modules in your environment and optionally retrieve corresponding data from blukii Info Manager.
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (delegate <code>onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
/// var mBlukiiClient: BKClient!
///
/// override func viewDidLoad() {
///     ...
///     mBlukiiClient = BKClient()
///     mBlukiiClient.discoveryDelegate = self
///     mBlukiiClient.initDiscovery()
///     ...
/// }
///
/// func onInitialized() {
///     if mBlukiiClient.startDiscovery() {
///         // Discovery successfully started
///     }
/// }
///
/// func onDiscoveryResult(discoveryResultList: [BlukiiInfo.BKOutputElement]) { }
/// func onDiscoveryError(errorCode: BlukiiInfo.BKClient.ErrorCode) { }
/// func onDiscoveryInfo(infoCode: BlukiiInfo.BKClient.InfoCode) { }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
/// func onInitialized() {
///       // Discovery successfully initialized
///
///       let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///       discoverySettings.setRssiThreshold(-100)
///       discoverySettings.scanDuration = 10000
///       ...
///
///       if mBlukiiClient.startDiscovery() {
///           // Discovery successfully started
///       }
///  }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_: )</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKClient.InfoCode.INFO_DISCOVERY_PAUSED</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the iBeacon Region 123456789AB-CDEF-01234-00000000002 or 123456789AB-CDEF-01234-00000000003. In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Configure resolver settings</h3>
/// Use the <code>BKResolveSettings</code>object for configuring the resolving of the blukii Info Manager data.
/// Call <code>BKClient.resolveSettings</code>to retrieve the settings property set.
/// <em>Note:</em> <code>BKResolveSettings.resolveEnabled</code> has to be set true to enable the resolver!
/// \code
/// func onInitialized() {
///       // Discovery successfully initialized
///
///       let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///       discoverySettings.setRssiThreshold(-100)
///       discoverySettings.scanDuration = 10000
///       ...
///       
///       // change resolver settings
///       let resolveSettings: BKResolveSettings = mBlukiiClient.resolveSettings
///       resolveSettings.resolveEnabled = true
///       resolveSettings.setLanguagePriority([BKResolveSettings.OutputLanguage.English, BKResolveSettings.OutputLanguage.German])
///       ...
///
///       if mBlukiiClient.startDiscovery() {
///           // Discovery successfully started
///       }
///  }
///
/// \endcode<h3>4. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
/// func onDiscoveryResult(discoveryResultList: [BKOutputElement]) {
///   // Discovery phase has finished: list of OutputElements are retrieved
///
///   for outputElement in discoveryResultList {
///      let id = outputElement.id
///      let rssi = outputElement.discoveryData?.rssi
///      ...
///   }
/// }
///
/// \endcode<h3>5. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(BKClient.ErrorCode)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(BKClient.InfoCode)</code> will be called if there is important information about the discover process.
/// \code
/// func onDiscoveryError(errorCode: BKClient.ErrorCode) {
///     // An error has been sent from discover
/// }
///
/// func onDiscoveryInfo(infoCode: BKClient.InfoCode) {
///     // An info has been sent from discovery
/// }
///
/// \endcode<h2>B. Resolve data for a single blukii module or tag from blukii Info Manager</h2>
/// Retrieve data for a module or tag from blukii Info Manager by calling <code>resolveInputElement(InputElement)</code>
/// You have to prepare an <code>BKInputElement</code> that stands for a blukii number, NFC tag or scan result. Please see <code>BKInputElement</code> for more Information.
/// If the resolving proccess is successfull the delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code> is called.
/// Otherwise the delegate <code>BKClientResolveDelegate.onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode)</code> lets you know the error of the resolving proccess.
/// \code
/// mBlukiiClient.resolveDelegate = self
///
/// func resolveSingleElement() {
///     // call resolver
///     let inputElement = BKInputElement(tagID: "", inputType: BKInputSourceType.NFC)
///     mBlukiiClient.resolveInputElement(inputElement)
/// }
///
/// func onResolveInputElementResult(outputElement: BKOutputElement) {
///     let id = outputElement.id
///     let url = outputElement.resolveData?.url
/// }
///
/// func onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode) {
///     // An error has been sent from resolver
/// }
///
/// \endcode<h2>C. Resolving news from blukii Info Manager</h2>
/// Retrieve a translated news text from the blukii Info Manager.
/// If the resolving process is successfull the delegate <code>BKClientNewsDelegate.onNewsResult(news: String)</code> is called.
/// Otherwise the delegate <code>BKClientNewsDelegate.onNewsError(errorCode: BKClient.ErrorCode)</code> lets you know the error of the resolving process.
/// \code
/// mBlukiiClient.newsDelegate = self
///
/// func resolveNews() {
///     mBlukiiClient.resolveServerNews("en-gb")
/// }
///
/// func onNewsResult(news: String) {
///     // news retrieved
/// }
///
/// func onNewsError(errorCode: BlukiiInfo.BKClient.ErrorCode) {
///     // An error has been sent from resolver
/// }
///
/// \endcode
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is a part of <code>BKOutputElement</code>
/// It will be set if the <code>BKOutputElement</code> is returned by the delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> after calling BKClient.initDiscovery(). For Other BKClient delegates BKDiscoveryData is <code>nil</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Data Object that defines the input data for resolving requests to blukii Info Manager (https://manager.blukiiinfo.com).
/// It is used in two cases:
/// <ul>
///   <li>
///     <em>Delegate</em> <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code>:
///   </li>
/// </ul>
/// <code>BKInputElement</code> is part of every <code>BKOutputElement</code>. It contains input type <code>BKInputSourceTpye.BLUKII</code> and the device name of the discovered BLE module.
/// <ul>
///   <li>
///     <em>Function</em> <code>BKClient.resolveInputElement(BKInputElement)</code>:
///   </li>
/// </ul>
/// <code>BKInputElement</code> is used as input property for a single recolving action. It has to be created by initializer <code>BKInputElement(String, BKInputSourceType)</code>.
/// If resolving is successful it will be unmodified part of <code>BKOutputElement</code> that is returned by delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code>
SWIFT_CLASS("_TtC10BlukiiInfo14BKInputElement")
@interface BKInputElement : NSObject <NSSecureCoding>
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class BKResolveData;

/// Read only data object for data of BLE discover and resolving process.
/// <code>BKOutputElement</code> is returned by delegates of the BKClient functions for discovery and resolve of BLE modules.
/// It is an combination of data that is encapsulated in specific data objects:
/// <ul>
///   <li>
///     <code>BKInputElement</code>: input data that is created by discovery process (blukii number) or external inputs (NFC tag id, scan of barcodes).
///     A cnversion of the <code>BKInputelement.tagID</code> is saved in <code>id</code>
///   </li>
///   <li>
///     <code>BKDiscoveryData</code>: emitted data of the BLE module
///   </li>
///   <li>
///     <code>BKResolveData</code>: resolved data requested from blukii Info Manager (https://manager.blukiiinfo.com)
///     The state of resolve process is saved by <code>resolveState</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC10BlukiiInfo15BKOutputElement")
@interface BKOutputElement : NSObject <NSSecureCoding>
/// The blukii number of the OutputElement
/// In Some cases it is a coversion of the input tag id (see <code>BKInputElement.tagID</code>)
/// If it is an iBeacon the id is <UUID><Major><Minor>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The resolved data from blukii Info Manager (https://manager.blukiiinfo.com)
/// For more information see <code>BKResolveData</code>
/// returns the data object of resolved data
@property (nonatomic, readonly, strong) BKResolveData * _Nullable resolveData;
/// The emitted BLE data of one module
/// For more information see BKDiscoveryData
/// returns data object of discovered BLE data
@property (nonatomic, readonly, strong) BKDiscoveryData * _Nullable discoveryData;
/// The input data (tag id and type)
/// For more Information see <code>BKInputElement</code>
/// returns data object of input data
@property (nonatomic, readonly, strong) BKInputElement * _Nullable inputElement;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class NSNumber;

/// Read only data object for resolved output data of the blukii info manager
/// <code>BKResolveData</code> can be valid for blukii modules only.
/// It contains the result of a data request to the blukii Info Manager (https://manager.blukiiinfo.com).
/// The <code>BKResolveData</code> fields contain the values of on corresponding blukii number.
/// <code>BKResolveData</code> is part of <code>BKOutputElement</code>
/// It will be set for the following cases:
/// <ul>
///   <li>
///     OutputElement ID (see <code>BKOutputElement.id</code>) must be configured as a blukii number on the blukii Info Manager by an Info Manger user. This is an requierement for all <code>BKClient</code> delegates!
///   </li>
///   <li>
///     <code>BKResolveData</code> will be requested during the discovery (see <code>BKClient.initDiscovery()</code>) for all discovered Elelements if the setting <code>BKResolveSettings.resolveEnabled</code> is set true. If some data is responded it will be returned as part of an <code>BKOutputElement</code> by delegate <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> The result state of resolving can additionally be read by calling <code>BKOuputElement.resolveState</code>:
///     <ul>
///       <li>
///         UNRESOLVED: Resolve is off (<code>BKResolveSettings.resolveEnabled</code> is false) or blukii Info Manager is not connectable
///       </li>
///       <li>
///         RESOLVED: blukii Info Manager has responded data for the OutputElement ID
///       </li>
///       <li>
///         NODATA: blukii Info Manager is connectable but has responded no data for the OutputElement ID
///       </li>
///       <li>
///         CACHED: ResolveData contains cached data that has been responded earlier (see cache settings on <code>BKResolveSettings</code>)
///       </li>
///     </ul>
///   </li>
///   <li>
///     <code>BKResolveData</code> will be requested for a single Element by calling (see <code>BKClient.resolveInputElement(BKInputElement)</code>). If some data is responded it will be returned as part of an <code>BKOutputElement</code> by delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code>. The result state of resolving can additionally be read by calling <code>BKOutputElement.resolveState</code>. For single element requests there is no cache available.
///     <ul>
///       <li>
///         RESOLVED: blukii Info Manager has responded data for the OutputElement ID
///       </li>
///       <li>
///         NODATA: blukii Info Manager has not responded data for the OutputElement ID
///       </li>
///     </ul>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC10BlukiiInfo13BKResolveData")
@interface BKResolveData : NSObject <NSSecureCoding>
/// The value of the language specific blukii number field <em>Title</em>
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> If the language specific field <em>Title</em> is not set <code>title</code> contains the value of field <em>Name</em> (as fallback)
/// Value of blukii number field <em>Title</em>
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The Value of the language specific blukii number field <em>URL</em>
/// The language is defined by property <code>language</code>
/// <em>Note:</em> In most cases getUrl returns an url to a OutputType specific file. Exceptions are:
/// <ul>
///   <li>
///     OutputType <code>BKOutputType.MESSAGE</code>: The message text itself will be returned.
///   </li>
///   <li>
///     Resolving single elements of <code>BKInputSourceType.SCAN</code> by <code>BlukiiClient.resolveInputElement(BKInputElement)</code>: If you resolve a QR code with format <code>BKOutputType.WIFI</code> or <code>BKOutputType.VCARD</code> the WIFI or VCARD formatted code will be returned.
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// The output language of the BKResolveData set.
/// It shows the language specific selection of the blukii number fields <code>url</code> and <code>title</code>, for <code>BKOutputType.PDF</code> also of <code>urlExtra</code> and <code>plainTextExtra</code>
/// The output language is chosen by the resolver process. If only one language specific blukii number URL and title is defined it will be returned. Otherwise the language is chosen according the language priority setting (see <code>BKResolveSettings.getLanguagePriority()</code>)
/// The value can be one of the following languages codes: en-gb, fr-fr or de-de
@property (nonatomic, readonly, copy) NSString * _Nullable language;
/// Preview Image from Backend
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable name;
@property (nonatomic, readonly, strong) NSNumber * _Nullable infoProviderId;
/// The value of the date where the blukii Number was resolved
///
/// returns:
/// NSDate object
@property (nonatomic, readonly, copy) NSDate * _Nonnull resolveDate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the resolving process of data from blukii Info Manager (https://manager.blukiiinfo.com)
/// You can access the BKResolveSettings by calling <code>BKClient.resolveSettings</code>
/// Every settings value is writeable and has a default value that is used if not changed by the developer.
/// With the exception of <code>getLanguagePriority()</code> the ResolveSettings properties are only affecting the discovery process that is started by <code>BKClient.initDiscovery()</code>
/// For the single resolving process that is started by <code>BKClient.resolveInputElement(input: BKInputElement)</code> only <code>getLanguagePriority()</code> is relevant.
SWIFT_CLASS("_TtC10BlukiiInfo17BKResolveSettings")
@interface BKResolveSettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.0.1 effective-4.2 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// <h1>Main Controller class for discovering BLE modules and resolving blukii concerned data from the blukii Info Manager.</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE data and resolving data from blukii Info Manager (https://manager.blukiiinfo.com)
///   </li>
///   <li>
///     Resolving data for a single blukii module or tag from blukii Info Manager
///   </li>
///   <li>
///     Resolving news from blukii Info Manager
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules, extract their BLE data and resolve their data from blukii Info Manager</h2>
/// Use this feature to discover BLE modules in your environment and optionally retrieve corresponding data from blukii Info Manager.
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (delegate <code>onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
/// var mBlukiiClient: BKClient!
///
/// override func viewDidLoad() {
///     ...
///     mBlukiiClient = BKClient()
///     mBlukiiClient.discoveryDelegate = self
///     mBlukiiClient.initDiscovery()
///     ...
/// }
///
/// func onInitialized() {
///     if mBlukiiClient.startDiscovery() {
///         // Discovery successfully started
///     }
/// }
///
/// func onDiscoveryResult(discoveryResultList: [BlukiiInfo.BKOutputElement]) { }
/// func onDiscoveryError(errorCode: BlukiiInfo.BKClient.ErrorCode) { }
/// func onDiscoveryInfo(infoCode: BlukiiInfo.BKClient.InfoCode) { }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
/// func onInitialized() {
///       // Discovery successfully initialized
///
///       let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///       discoverySettings.setRssiThreshold(-100)
///       discoverySettings.scanDuration = 10000
///       ...
///
///       if mBlukiiClient.startDiscovery() {
///           // Discovery successfully started
///       }
///  }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_: )</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKClient.InfoCode.INFO_DISCOVERY_PAUSED</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the iBeacon Region 123456789AB-CDEF-01234-00000000002 or 123456789AB-CDEF-01234-00000000003. In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Configure resolver settings</h3>
/// Use the <code>BKResolveSettings</code>object for configuring the resolving of the blukii Info Manager data.
/// Call <code>BKClient.resolveSettings</code>to retrieve the settings property set.
/// <em>Note:</em> <code>BKResolveSettings.resolveEnabled</code> has to be set true to enable the resolver!
/// \code
/// func onInitialized() {
///       // Discovery successfully initialized
///
///       let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///       discoverySettings.setRssiThreshold(-100)
///       discoverySettings.scanDuration = 10000
///       ...
///       
///       // change resolver settings
///       let resolveSettings: BKResolveSettings = mBlukiiClient.resolveSettings
///       resolveSettings.resolveEnabled = true
///       resolveSettings.setLanguagePriority([BKResolveSettings.OutputLanguage.English, BKResolveSettings.OutputLanguage.German])
///       ...
///
///       if mBlukiiClient.startDiscovery() {
///           // Discovery successfully started
///       }
///  }
///
/// \endcode<h3>4. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
/// func onDiscoveryResult(discoveryResultList: [BKOutputElement]) {
///   // Discovery phase has finished: list of OutputElements are retrieved
///
///   for outputElement in discoveryResultList {
///      let id = outputElement.id
///      let rssi = outputElement.discoveryData?.rssi
///      ...
///   }
/// }
///
/// \endcode<h3>5. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(BKClient.ErrorCode)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(BKClient.InfoCode)</code> will be called if there is important information about the discover process.
/// \code
/// func onDiscoveryError(errorCode: BKClient.ErrorCode) {
///     // An error has been sent from discover
/// }
///
/// func onDiscoveryInfo(infoCode: BKClient.InfoCode) {
///     // An info has been sent from discovery
/// }
///
/// \endcode<h2>B. Resolve data for a single blukii module or tag from blukii Info Manager</h2>
/// Retrieve data for a module or tag from blukii Info Manager by calling <code>resolveInputElement(InputElement)</code>
/// You have to prepare an <code>BKInputElement</code> that stands for a blukii number, NFC tag or scan result. Please see <code>BKInputElement</code> for more Information.
/// If the resolving proccess is successfull the delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code> is called.
/// Otherwise the delegate <code>BKClientResolveDelegate.onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode)</code> lets you know the error of the resolving proccess.
/// \code
/// mBlukiiClient.resolveDelegate = self
///
/// func resolveSingleElement() {
///     // call resolver
///     let inputElement = BKInputElement(tagID: "", inputType: BKInputSourceType.NFC)
///     mBlukiiClient.resolveInputElement(inputElement)
/// }
///
/// func onResolveInputElementResult(outputElement: BKOutputElement) {
///     let id = outputElement.id
///     let url = outputElement.resolveData?.url
/// }
///
/// func onResolveInputElementError(inputElement: BKInputElement, errorCode: BKClient.ErrorCode) {
///     // An error has been sent from resolver
/// }
///
/// \endcode<h2>C. Resolving news from blukii Info Manager</h2>
/// Retrieve a translated news text from the blukii Info Manager.
/// If the resolving process is successfull the delegate <code>BKClientNewsDelegate.onNewsResult(news: String)</code> is called.
/// Otherwise the delegate <code>BKClientNewsDelegate.onNewsError(errorCode: BKClient.ErrorCode)</code> lets you know the error of the resolving process.
/// \code
/// mBlukiiClient.newsDelegate = self
///
/// func resolveNews() {
///     mBlukiiClient.resolveServerNews("en-gb")
/// }
///
/// func onNewsResult(news: String) {
///     // news retrieved
/// }
///
/// func onNewsError(errorCode: BlukiiInfo.BKClient.ErrorCode) {
///     // An error has been sent from resolver
/// }
///
/// \endcode
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is a part of <code>BKOutputElement</code>
/// It will be set if the <code>BKOutputElement</code> is returned by the delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> after calling BKClient.initDiscovery(). For Other BKClient delegates BKDiscoveryData is <code>nil</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Data Object that defines the input data for resolving requests to blukii Info Manager (https://manager.blukiiinfo.com).
/// It is used in two cases:
/// <ul>
///   <li>
///     <em>Delegate</em> <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code>:
///   </li>
/// </ul>
/// <code>BKInputElement</code> is part of every <code>BKOutputElement</code>. It contains input type <code>BKInputSourceTpye.BLUKII</code> and the device name of the discovered BLE module.
/// <ul>
///   <li>
///     <em>Function</em> <code>BKClient.resolveInputElement(BKInputElement)</code>:
///   </li>
/// </ul>
/// <code>BKInputElement</code> is used as input property for a single recolving action. It has to be created by initializer <code>BKInputElement(String, BKInputSourceType)</code>.
/// If resolving is successful it will be unmodified part of <code>BKOutputElement</code> that is returned by delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code>
SWIFT_CLASS("_TtC10BlukiiInfo14BKInputElement")
@interface BKInputElement : NSObject <NSSecureCoding>
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class BKResolveData;

/// Read only data object for data of BLE discover and resolving process.
/// <code>BKOutputElement</code> is returned by delegates of the BKClient functions for discovery and resolve of BLE modules.
/// It is an combination of data that is encapsulated in specific data objects:
/// <ul>
///   <li>
///     <code>BKInputElement</code>: input data that is created by discovery process (blukii number) or external inputs (NFC tag id, scan of barcodes).
///     A cnversion of the <code>BKInputelement.tagID</code> is saved in <code>id</code>
///   </li>
///   <li>
///     <code>BKDiscoveryData</code>: emitted data of the BLE module
///   </li>
///   <li>
///     <code>BKResolveData</code>: resolved data requested from blukii Info Manager (https://manager.blukiiinfo.com)
///     The state of resolve process is saved by <code>resolveState</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC10BlukiiInfo15BKOutputElement")
@interface BKOutputElement : NSObject <NSSecureCoding>
/// The blukii number of the OutputElement
/// In Some cases it is a coversion of the input tag id (see <code>BKInputElement.tagID</code>)
/// If it is an iBeacon the id is <UUID><Major><Minor>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The resolved data from blukii Info Manager (https://manager.blukiiinfo.com)
/// For more information see <code>BKResolveData</code>
/// returns the data object of resolved data
@property (nonatomic, readonly, strong) BKResolveData * _Nullable resolveData;
/// The emitted BLE data of one module
/// For more information see BKDiscoveryData
/// returns data object of discovered BLE data
@property (nonatomic, readonly, strong) BKDiscoveryData * _Nullable discoveryData;
/// The input data (tag id and type)
/// For more Information see <code>BKInputElement</code>
/// returns data object of input data
@property (nonatomic, readonly, strong) BKInputElement * _Nullable inputElement;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class NSNumber;

/// Read only data object for resolved output data of the blukii info manager
/// <code>BKResolveData</code> can be valid for blukii modules only.
/// It contains the result of a data request to the blukii Info Manager (https://manager.blukiiinfo.com).
/// The <code>BKResolveData</code> fields contain the values of on corresponding blukii number.
/// <code>BKResolveData</code> is part of <code>BKOutputElement</code>
/// It will be set for the following cases:
/// <ul>
///   <li>
///     OutputElement ID (see <code>BKOutputElement.id</code>) must be configured as a blukii number on the blukii Info Manager by an Info Manger user. This is an requierement for all <code>BKClient</code> delegates!
///   </li>
///   <li>
///     <code>BKResolveData</code> will be requested during the discovery (see <code>BKClient.initDiscovery()</code>) for all discovered Elelements if the setting <code>BKResolveSettings.resolveEnabled</code> is set true. If some data is responded it will be returned as part of an <code>BKOutputElement</code> by delegate <code>BKClientDiscoveryDelegate.onDiscoveryResult(discoveryResultList: [BKOutputElement])</code> The result state of resolving can additionally be read by calling <code>BKOuputElement.resolveState</code>:
///     <ul>
///       <li>
///         UNRESOLVED: Resolve is off (<code>BKResolveSettings.resolveEnabled</code> is false) or blukii Info Manager is not connectable
///       </li>
///       <li>
///         RESOLVED: blukii Info Manager has responded data for the OutputElement ID
///       </li>
///       <li>
///         NODATA: blukii Info Manager is connectable but has responded no data for the OutputElement ID
///       </li>
///       <li>
///         CACHED: ResolveData contains cached data that has been responded earlier (see cache settings on <code>BKResolveSettings</code>)
///       </li>
///     </ul>
///   </li>
///   <li>
///     <code>BKResolveData</code> will be requested for a single Element by calling (see <code>BKClient.resolveInputElement(BKInputElement)</code>). If some data is responded it will be returned as part of an <code>BKOutputElement</code> by delegate <code>BKClientResolveDelegate.onResolveInputElementResult(outputElement: BKOutputElement)</code>. The result state of resolving can additionally be read by calling <code>BKOutputElement.resolveState</code>. For single element requests there is no cache available.
///     <ul>
///       <li>
///         RESOLVED: blukii Info Manager has responded data for the OutputElement ID
///       </li>
///       <li>
///         NODATA: blukii Info Manager has not responded data for the OutputElement ID
///       </li>
///     </ul>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC10BlukiiInfo13BKResolveData")
@interface BKResolveData : NSObject <NSSecureCoding>
/// The value of the language specific blukii number field <em>Title</em>
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> If the language specific field <em>Title</em> is not set <code>title</code> contains the value of field <em>Name</em> (as fallback)
/// Value of blukii number field <em>Title</em>
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The Value of the language specific blukii number field <em>URL</em>
/// The language is defined by property <code>language</code>
/// <em>Note:</em> In most cases getUrl returns an url to a OutputType specific file. Exceptions are:
/// <ul>
///   <li>
///     OutputType <code>BKOutputType.MESSAGE</code>: The message text itself will be returned.
///   </li>
///   <li>
///     Resolving single elements of <code>BKInputSourceType.SCAN</code> by <code>BlukiiClient.resolveInputElement(BKInputElement)</code>: If you resolve a QR code with format <code>BKOutputType.WIFI</code> or <code>BKOutputType.VCARD</code> the WIFI or VCARD formatted code will be returned.
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// The output language of the BKResolveData set.
/// It shows the language specific selection of the blukii number fields <code>url</code> and <code>title</code>, for <code>BKOutputType.PDF</code> also of <code>urlExtra</code> and <code>plainTextExtra</code>
/// The output language is chosen by the resolver process. If only one language specific blukii number URL and title is defined it will be returned. Otherwise the language is chosen according the language priority setting (see <code>BKResolveSettings.getLanguagePriority()</code>)
/// The value can be one of the following languages codes: en-gb, fr-fr or de-de
@property (nonatomic, readonly, copy) NSString * _Nullable language;
/// Preview Image from Backend
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable name;
@property (nonatomic, readonly, strong) NSNumber * _Nullable infoProviderId;
/// The value of the date where the blukii Number was resolved
///
/// returns:
/// NSDate object
@property (nonatomic, readonly, copy) NSDate * _Nonnull resolveDate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the resolving process of data from blukii Info Manager (https://manager.blukiiinfo.com)
/// You can access the BKResolveSettings by calling <code>BKClient.resolveSettings</code>
/// Every settings value is writeable and has a default value that is used if not changed by the developer.
/// With the exception of <code>getLanguagePriority()</code> the ResolveSettings properties are only affecting the discovery process that is started by <code>BKClient.initDiscovery()</code>
/// For the single resolving process that is started by <code>BKClient.resolveInputElement(input: BKInputElement)</code> only <code>getLanguagePriority()</code> is relevant.
SWIFT_CLASS("_TtC10BlukiiInfo17BKResolveSettings")
@interface BKResolveSettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif
