#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Main controller class of package info, for interacting with blukii Manager Info CMS (@see  https://manager.blukii.com)
/// BlukiiClient class contains discovery functions as follows:
/// <ul>
///   <li>
///     Request for getting blukii Info output data.
///   </li>
///   <li>
///     Reporting of blukii Info clicks.
///   </li>
///   <li>
///     Reporting of blukii Info violations.
///   </li>
/// </ul>
/// <em>Note:</em> These functions needs to set an developers API key by <code>BKBlukiiCloud.setApiKey(apiKey:)</code>. Settings of credentials and user login is not needed for BlukiiInfo functions.
SWIFT_CLASS("_TtC10BlukiiInfo12BKBlukiiInfo")
@interface BKBlukiiInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <h1>Main Controller class for discovering BLE modules</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE advertised data
///   </li>
///   <li>
///     Decryption of blukii SecureBeacon advertising
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules and extract their BLE data</h2>
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (<code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
///  var mBlukiiClient: BKClient!
///
///  override func viewDidLoad() {
///      ...
///      mBlukiiClient = BKController.instance.getDiscoveryClient()
///      mBlukiiClient.discoveryDelegate = self
///      mBlukiiClient.initDiscovery()
///      ...
///  }
///
///  func stopDiscovery() {
///      mBlukiiClient.stopDiscovery()
///  }
///
///  // Discovery Delegate
///  func onDiscoveryInitialized() {
///      if mBlukiiClient.startDiscovery() {
///          // Discovery successfully started
///      }
///  }
///
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///      // retrieve BLE results
///  }
///
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // retrieve errors
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // retrieve infos and changed states
///  }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
///  func onInitialized() {
///        // Discovery successfully initialized
///
///        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///        discoverySettings.setRssiThreshold(-100)
///        discoverySettings.scanDuration = 10000
///        ...
///
///        if mBlukiiClient.startDiscovery() {
///            // Discovery successfully started
///        }
///   }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKDiscoveryInfo.bleScanPaused</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the Configured iBeacon Region. Background scanning will only Scan, if the device is in the configured iBeacon Region and the display will be switched on.  In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///    // Discovery phase has finished: list of OutputElements are retrieved
///
///    for discoveryData in discoveryResultList {
///       let id = discoveryData.blukiiId
///       let rssi = discoveryData.getRssi()
///       ...
///    }
///  }
///
/// \endcode<h3>4. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(_:)</code> will be called if there is important information about the discover process.
/// \code
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // An error has been sent from discover
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // An info has been sent from discovery
///  }
///
/// \endcode<h3>5. Permission</h3>
/// In Info.plist set the following keys for Beacon Detection:
/// <ul>
///   <li>
///     NSLocationAlwaysUsageDescription
///   </li>
///   <li>
///     NSBluetoothAlwaysUsageDescription
///   </li>
/// </ul>
/// Add the Follow Capapilities to your Project, for scanning Beacons in Background:
/// <ul>
///   <li>
///     Background Mode: Location Updates
///   </li>
///   <li>
///     Background Mode: Uses Bluetooth LE accessoires
///   </li>
/// </ul>
/// <h2>B. Decryption of SecureBeacon advertising</h2>
/// blukii SecureBeacons are encrypted to prevent third parties from misusing the Beacon identification.
/// The encryption is affecting the mac address and the iBeacon Major and Minor value.
/// You can decrypt DiscoveryData by calling  <code> decryptSecureBeacons(discoveryDataList:)</code>. To detect a SecureBeacon, you have to set your secureBeacon UUID to <code>BKDiscoverySettings.securebeaconUUID</code>
/// The delegate <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code>  is retrieving a copy of the input parameter list containing decrypted values. Each BKDiscoveryData object, that has been decrypted is marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.decrypted</code>.
/// \code
/// func onDecryptSecureBeacons(_ decryptedDiscoveryDataList: [BKDiscoveryData], decryptedCount: Int) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons Successful: Count=" +  decryptedCount)
/// }
///
/// func onDecryptError(_ error: Error) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons failed: error=" + error.localizedDescription)
/// }
///
/// \endcode<em>Note:</em> SecureBeacons can only be decrypted by its owner, so the corresponding user needs to be logged in (@see <code>BKBlukiiCloud</code>)
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is returned by teh delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoBundleOutputData;

/// Read only data object for Info Bundle data retrieved from blukii Manager Info CMS.
/// It contains the results of the <code>BKBlukiiInfo.getInfoBundles(bundleIds:completionHandler:)</code> request to the blukii Manager Info CMS (https://manager.blukii.com).
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoBundleData")
@interface BKInfoBundleData : NSObject <NSCoding>
/// The Bundle Id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The map of bundle output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> Englisch
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this dictionary only contains ouput data of languages that are configured for the Bundle on blukii Manager CMS.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoBundleOutputData *> * _Nonnull outputDataList;
/// If the InfoData items has been marked as protected.
/// true, if protedted
@property (nonatomic, readonly) BOOL itemsProtected;
/// The timestamp of last retrieve from blukii Manager.
/// timestamp in milliseconds
@property (nonatomic, readonly) int64_t timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
@end


/// Read only data object for output language based info bundle data retrieved from blukii Manager Info CMS.
/// It is a child object of  <code>BKInfoBundleData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo22BKInfoBundleOutputData")
@interface BKInfoBundleOutputData : NSObject <NSCoding>
/// The value of the language specific Title.
/// <em>Note:</em> If the language specific field Title is not set title contains the value of field <code>BKInfoBundleData.name</code> (as fallback).
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The url of the Bundles Preview Image.
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoOutputData;

/// Read only data object for data of BLE discover and resolving process.
/// It contains the results of the <code>BKBlukiiInfo.getInfoData(blukiiIds:completionHandler:)</code> request to the blukii Manager Info CMS(https://manager.blukii.com).
/// The BKInfoData fields contain the values of one corresponding blukii number.
SWIFT_CLASS("_TtC10BlukiiInfo10BKInfoData")
@interface BKInfoData : NSObject <NSSecureCoding>
/// The Info data id.
///
/// returns:
/// id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The blukii Numbers of the Info.
///
/// returns:
/// Blukii Id list
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull blukiiList;
/// The map of Info output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> English
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this map only contains output data of languages that are configured for the Info on blukii Manager CMS.
///
/// returns:
/// map of ouput data
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoOutputData *> * _Nonnull outputDataList;
/// The value of the blukii number field Visibility range.
/// This value contains a Bluetooth module defined value for the rssi range in addition to the global rssi setting (@see <code>BKDiscoverySettings.getRssiThreshold()</code>.
/// It does not affect the BLE scan itself but is designed for a better output handling.
///
/// returns:
/// Value of blukii number field Visibility range
@property (nonatomic, readonly) int64_t rssi;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nullable condition;
/// The identifiable name of the Info data.
///
/// returns:
/// Info Data Name
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// :nodoc:
@property (nonatomic, readonly) NSInteger infoProviderId;
/// The timestamp of last retrieve from blukii Manager.
///
/// returns:
/// Timestamp as <code>Date</code>
@property (nonatomic, readonly, copy) NSDate * _Nonnull timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for output language based blukii data retrieved from blukii Manager Info CMS.
/// It is a child object of <code>BKInfoData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoOutputData")
@interface BKInfoOutputData : NSObject <NSCoding>
/// The value of output <em>Title</em>
///
/// returns:
/// Value of Title
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The value of output <em>URL</em>.
///
/// returns:
/// Value of URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// Gets the url of <em>preview Image</em>
///
/// returns:
/// Value of preview url
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
/// The value of the <em>Audio File URL</em>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a url of an audio file.
///
/// returns:
/// Value of Audio File URL of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable urlExtra;
/// The value of  <em>Text to speech</em>.
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a text.
///
/// returns:
/// Value of Text to speech of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable plainTextExtra;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
@end


/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class NSNumber;

/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7S__) && __ARM_ARCH_7S__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Main controller class of package info, for interacting with blukii Manager Info CMS (@see  https://manager.blukii.com)
/// BlukiiClient class contains discovery functions as follows:
/// <ul>
///   <li>
///     Request for getting blukii Info output data.
///   </li>
///   <li>
///     Reporting of blukii Info clicks.
///   </li>
///   <li>
///     Reporting of blukii Info violations.
///   </li>
/// </ul>
/// <em>Note:</em> These functions needs to set an developers API key by <code>BKBlukiiCloud.setApiKey(apiKey:)</code>. Settings of credentials and user login is not needed for BlukiiInfo functions.
SWIFT_CLASS("_TtC10BlukiiInfo12BKBlukiiInfo")
@interface BKBlukiiInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <h1>Main Controller class for discovering BLE modules</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE advertised data
///   </li>
///   <li>
///     Decryption of blukii SecureBeacon advertising
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules and extract their BLE data</h2>
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (<code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
///  var mBlukiiClient: BKClient!
///
///  override func viewDidLoad() {
///      ...
///      mBlukiiClient = BKController.instance.getDiscoveryClient()
///      mBlukiiClient.discoveryDelegate = self
///      mBlukiiClient.initDiscovery()
///      ...
///  }
///
///  func stopDiscovery() {
///      mBlukiiClient.stopDiscovery()
///  }
///
///  // Discovery Delegate
///  func onDiscoveryInitialized() {
///      if mBlukiiClient.startDiscovery() {
///          // Discovery successfully started
///      }
///  }
///
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///      // retrieve BLE results
///  }
///
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // retrieve errors
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // retrieve infos and changed states
///  }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
///  func onInitialized() {
///        // Discovery successfully initialized
///
///        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///        discoverySettings.setRssiThreshold(-100)
///        discoverySettings.scanDuration = 10000
///        ...
///
///        if mBlukiiClient.startDiscovery() {
///            // Discovery successfully started
///        }
///   }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKDiscoveryInfo.bleScanPaused</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the Configured iBeacon Region. Background scanning will only Scan, if the device is in the configured iBeacon Region and the display will be switched on.  In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///    // Discovery phase has finished: list of OutputElements are retrieved
///
///    for discoveryData in discoveryResultList {
///       let id = discoveryData.blukiiId
///       let rssi = discoveryData.getRssi()
///       ...
///    }
///  }
///
/// \endcode<h3>4. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(_:)</code> will be called if there is important information about the discover process.
/// \code
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // An error has been sent from discover
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // An info has been sent from discovery
///  }
///
/// \endcode<h3>5. Permission</h3>
/// In Info.plist set the following keys for Beacon Detection:
/// <ul>
///   <li>
///     NSLocationAlwaysUsageDescription
///   </li>
///   <li>
///     NSBluetoothAlwaysUsageDescription
///   </li>
/// </ul>
/// Add the Follow Capapilities to your Project, for scanning Beacons in Background:
/// <ul>
///   <li>
///     Background Mode: Location Updates
///   </li>
///   <li>
///     Background Mode: Uses Bluetooth LE accessoires
///   </li>
/// </ul>
/// <h2>B. Decryption of SecureBeacon advertising</h2>
/// blukii SecureBeacons are encrypted to prevent third parties from misusing the Beacon identification.
/// The encryption is affecting the mac address and the iBeacon Major and Minor value.
/// You can decrypt DiscoveryData by calling  <code> decryptSecureBeacons(discoveryDataList:)</code>. To detect a SecureBeacon, you have to set your secureBeacon UUID to <code>BKDiscoverySettings.securebeaconUUID</code>
/// The delegate <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code>  is retrieving a copy of the input parameter list containing decrypted values. Each BKDiscoveryData object, that has been decrypted is marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.decrypted</code>.
/// \code
/// func onDecryptSecureBeacons(_ decryptedDiscoveryDataList: [BKDiscoveryData], decryptedCount: Int) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons Successful: Count=" +  decryptedCount)
/// }
///
/// func onDecryptError(_ error: Error) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons failed: error=" + error.localizedDescription)
/// }
///
/// \endcode<em>Note:</em> SecureBeacons can only be decrypted by its owner, so the corresponding user needs to be logged in (@see <code>BKBlukiiCloud</code>)
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is returned by teh delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoBundleOutputData;

/// Read only data object for Info Bundle data retrieved from blukii Manager Info CMS.
/// It contains the results of the <code>BKBlukiiInfo.getInfoBundles(bundleIds:completionHandler:)</code> request to the blukii Manager Info CMS (https://manager.blukii.com).
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoBundleData")
@interface BKInfoBundleData : NSObject <NSCoding>
/// The Bundle Id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The map of bundle output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> Englisch
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this dictionary only contains ouput data of languages that are configured for the Bundle on blukii Manager CMS.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoBundleOutputData *> * _Nonnull outputDataList;
/// If the InfoData items has been marked as protected.
/// true, if protedted
@property (nonatomic, readonly) BOOL itemsProtected;
/// The timestamp of last retrieve from blukii Manager.
/// timestamp in milliseconds
@property (nonatomic, readonly) int64_t timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
@end


/// Read only data object for output language based info bundle data retrieved from blukii Manager Info CMS.
/// It is a child object of  <code>BKInfoBundleData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo22BKInfoBundleOutputData")
@interface BKInfoBundleOutputData : NSObject <NSCoding>
/// The value of the language specific Title.
/// <em>Note:</em> If the language specific field Title is not set title contains the value of field <code>BKInfoBundleData.name</code> (as fallback).
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The url of the Bundles Preview Image.
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoOutputData;

/// Read only data object for data of BLE discover and resolving process.
/// It contains the results of the <code>BKBlukiiInfo.getInfoData(blukiiIds:completionHandler:)</code> request to the blukii Manager Info CMS(https://manager.blukii.com).
/// The BKInfoData fields contain the values of one corresponding blukii number.
SWIFT_CLASS("_TtC10BlukiiInfo10BKInfoData")
@interface BKInfoData : NSObject <NSSecureCoding>
/// The Info data id.
///
/// returns:
/// id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The blukii Numbers of the Info.
///
/// returns:
/// Blukii Id list
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull blukiiList;
/// The map of Info output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> English
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this map only contains output data of languages that are configured for the Info on blukii Manager CMS.
///
/// returns:
/// map of ouput data
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoOutputData *> * _Nonnull outputDataList;
/// The value of the blukii number field Visibility range.
/// This value contains a Bluetooth module defined value for the rssi range in addition to the global rssi setting (@see <code>BKDiscoverySettings.getRssiThreshold()</code>.
/// It does not affect the BLE scan itself but is designed for a better output handling.
///
/// returns:
/// Value of blukii number field Visibility range
@property (nonatomic, readonly) int64_t rssi;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nullable condition;
/// The identifiable name of the Info data.
///
/// returns:
/// Info Data Name
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// :nodoc:
@property (nonatomic, readonly) NSInteger infoProviderId;
/// The timestamp of last retrieve from blukii Manager.
///
/// returns:
/// Timestamp as <code>Date</code>
@property (nonatomic, readonly, copy) NSDate * _Nonnull timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for output language based blukii data retrieved from blukii Manager Info CMS.
/// It is a child object of <code>BKInfoData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoOutputData")
@interface BKInfoOutputData : NSObject <NSCoding>
/// The value of output <em>Title</em>
///
/// returns:
/// Value of Title
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The value of output <em>URL</em>.
///
/// returns:
/// Value of URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// Gets the url of <em>preview Image</em>
///
/// returns:
/// Value of preview url
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
/// The value of the <em>Audio File URL</em>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a url of an audio file.
///
/// returns:
/// Value of Audio File URL of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable urlExtra;
/// The value of  <em>Text to speech</em>.
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a text.
///
/// returns:
/// Value of Text to speech of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable plainTextExtra;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
@end


/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class NSNumber;

/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="BlukiiInfo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

/// Read only data set for 3D axis data
SWIFT_CLASS("_TtC10BlukiiInfo10BKAxisData")
@interface BKAxisData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for sensor data that is emitted by blukii beacons
/// BeaconSensor values are part of <code>BKDiscoveryData</code>
/// seealso:
/// <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo18BKBeaconSensorData")
@interface BKBeaconSensorData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Main controller class of package info, for interacting with blukii Manager Info CMS (@see  https://manager.blukii.com)
/// BlukiiClient class contains discovery functions as follows:
/// <ul>
///   <li>
///     Request for getting blukii Info output data.
///   </li>
///   <li>
///     Reporting of blukii Info clicks.
///   </li>
///   <li>
///     Reporting of blukii Info violations.
///   </li>
/// </ul>
/// <em>Note:</em> These functions needs to set an developers API key by <code>BKBlukiiCloud.setApiKey(apiKey:)</code>. Settings of credentials and user login is not needed for BlukiiInfo functions.
SWIFT_CLASS("_TtC10BlukiiInfo12BKBlukiiInfo")
@interface BKBlukiiInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <h1>Main Controller class for discovering BLE modules</h1>
/// BlukiiClient is a single point of contact for all data retieving actions as follows:
/// <ul>
///   <li>
///     Discovering BLE modules, extracting BLE advertised data
///   </li>
///   <li>
///     Decryption of blukii SecureBeacon advertising
///   </li>
/// </ul>
/// <h2>A. Discover BLE modules and extract their BLE data</h2>
/// To do this you have to do the following steps:
/// <h3>1. Initialize and start discovery</h3>
/// Call <code>initDiscovery()</code> and implement the <code>BKClientDiscoveryDelegate</code> delegates. After initialization is ready (<code>BKClientDiscoveryDelegate.onDiscoveryInitialized()</code>) you can start the discovery.
/// \code
///  var mBlukiiClient: BKClient!
///
///  override func viewDidLoad() {
///      ...
///      mBlukiiClient = BKController.instance.getDiscoveryClient()
///      mBlukiiClient.discoveryDelegate = self
///      mBlukiiClient.initDiscovery()
///      ...
///  }
///
///  func stopDiscovery() {
///      mBlukiiClient.stopDiscovery()
///  }
///
///  // Discovery Delegate
///  func onDiscoveryInitialized() {
///      if mBlukiiClient.startDiscovery() {
///          // Discovery successfully started
///      }
///  }
///
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///      // retrieve BLE results
///  }
///
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // retrieve errors
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // retrieve infos and changed states
///  }
///
/// \endcode<h3>2. Configure discovery settings</h3>
/// Use the <code>BKDiscoverySettings</code> object for configuring discovery. Get <code>BKClient.discoverySettings</code> to retrieve the settings property set.
/// \code
///  func onInitialized() {
///        // Discovery successfully initialized
///
///        let discoverySettings: BKDiscoverySettings = mBlukiiClient.discoverySettings
///        discoverySettings.setRssiThreshold(-100)
///        discoverySettings.scanDuration = 10000
///        ...
///
///        if mBlukiiClient.startDiscovery() {
///            // Discovery successfully started
///        }
///   }
///
/// \endcodeWhen BLE scanner is started the BLE discovery is acting according to the <code>BKDiscoverySettings</code>:
/// <ul>
///   <li>
///     The scanner is searching for BLE modules inside the defined rssi range (<code>BKDiscoverySettings.getRssiThreshold()</code>).
///   </li>
///   <li>
///     After one scan duration (<code>BKDiscoverySettings.scanDuration</code>) the results are called back to (<code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>)
///   </li>
///   <li>
///     This is repeated until BLE Scanning is stopped by <code>BKClient.stopDiscovery()</code> or the app did enter the background.
///   </li>
///   <li>
///     if the scanner is paused according to the <code>BKDiscoverySettings</code> the info <code>BKDiscoveryInfo.bleScanPaused</code> is called.
///   </li>
///   <li>
///     For background scanning it is necessary to be in the Configured iBeacon Region. Background scanning will only Scan, if the device is in the configured iBeacon Region and the display will be switched on.  In background it is possible to scan for iBeacon, EddystoneBeacon and InfoBeacon.
///   </li>
/// </ul>
/// <h3>3. Retrieve results</h3>
/// The callback <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code> will be called after finishing every discovery phase. It retrieves the discovered list of BKOutputElements.
/// <em>Note:</em> If no BLE modules have been found discoveryResultList is empty (not nil).
/// \code
///  func onDiscoveryResult(discoveryResultList: [BKDiscoveryData]) {
///    // Discovery phase has finished: list of OutputElements are retrieved
///
///    for discoveryData in discoveryResultList {
///       let id = discoveryData.blukiiId
///       let rssi = discoveryData.getRssi()
///       ...
///    }
///  }
///
/// \endcode<h3>4. Retrieve errors and infos</h3>
/// The callbacks <code>BKClientDiscoveryDelegate.onDiscoveryError(_:)</code> and <code>BKClientDiscoveryDelegate.onDiscoveryInfo(_:)</code> will be called if there is important information about the discover process.
/// \code
///  func onDiscoveryError(errorCode: BKDiscoveryError) {
///      // An error has been sent from discover
///  }
///
///  func onDiscoveryInfo(infoCode: BKDiscoveryInfo) {
///      // An info has been sent from discovery
///  }
///
/// \endcode<h3>5. Permission</h3>
/// In Info.plist set the following keys for Beacon Detection:
/// <ul>
///   <li>
///     NSLocationAlwaysUsageDescription
///   </li>
///   <li>
///     NSBluetoothAlwaysUsageDescription
///   </li>
/// </ul>
/// Add the Follow Capapilities to your Project, for scanning Beacons in Background:
/// <ul>
///   <li>
///     Background Mode: Location Updates
///   </li>
///   <li>
///     Background Mode: Uses Bluetooth LE accessoires
///   </li>
/// </ul>
/// <h2>B. Decryption of SecureBeacon advertising</h2>
/// blukii SecureBeacons are encrypted to prevent third parties from misusing the Beacon identification.
/// The encryption is affecting the mac address and the iBeacon Major and Minor value.
/// You can decrypt DiscoveryData by calling  <code> decryptSecureBeacons(discoveryDataList:)</code>. To detect a SecureBeacon, you have to set your secureBeacon UUID to <code>BKDiscoverySettings.securebeaconUUID</code>
/// The delegate <code>BKDecryptSecureBeaconsDelegate.onDecryptSecureBeacons(_:decryptedCount:)</code>  is retrieving a copy of the input parameter list containing decrypted values. Each BKDiscoveryData object, that has been decrypted is marked with <code>BKDiscoveryData.secureBeaconState</code> as <code>BKSecureBeaconState.decrypted</code>.
/// \code
/// func onDecryptSecureBeacons(_ decryptedDiscoveryDataList: [BKDiscoveryData], decryptedCount: Int) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons Successful: Count=" +  decryptedCount)
/// }
///
/// func onDecryptError(_ error: Error) {
///    print("BlukiiClient.onDiscoveryResult: DecryptSecureBeacons failed: error=" + error.localizedDescription)
/// }
///
/// \endcode<em>Note:</em> SecureBeacons can only be decrypted by its owner, so the corresponding user needs to be logged in (@see <code>BKBlukiiCloud</code>)
SWIFT_CLASS("_TtC10BlukiiInfo8BKClient")
@interface BKClient : NSObject
/// Constructor for initiating a blukii client.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for emitted data of on BLE module.
/// <code>BKDiscoveryData</code> is a collection of BLE data that is scanned during one scan duration for one BLE module.
/// It contains the following values if it is provided by the module’s hardware and firmware
/// <ul>
///   <li>
///     Device found date
///   </li>
///   <li>
///     RSSI value
///   </li>
///   <li>
///     blukii Hardware specific advertising data like firmware, blukii type, advertising interval, battery and txPower
///   </li>
///   <li>
///     Sensor data results of blukii sensor beacons. See <code>BKBeaconSensorData</code>
///   </li>
///   <li>
///     Key data of blukii SmartKeys. See <code>BKKeyData</code>
///   </li>
///   <li>
///     Eddystone protocol data values. See <code>BKEddystoneData</code>
///   </li>
///   <li>
///     iBeacon protocol data values. See <code>BKiBeaconData</code>
///   </li>
/// </ul>
/// <em>Note</em>: If the scan scan duration (see <code>BKDiscoverySettings.scanDuration</code>) is longer than the advertising interval of the module than each value is read only once. The following data frames of the same type are ignored if the corresponding fields are already set in the <code>BKDiscoveryData</code> object.
/// The discovery date (<code>deviceFoundDate</code>) is the timestamp of the last BLE frame that is scanned by the mobile device.
/// <code>BKDiscoveryData</code> is returned by teh delegate function <code>BKClientDiscoveryDelegate.onDiscoveryResult(_:)</code>
SWIFT_CLASS("_TtC10BlukiiInfo15BKDiscoveryData")
@interface BKDiscoveryData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Property set of settings to configure the discovering process.
/// The DiscoverySettings properties are affecting the discovery process that is started by <code>BKClient.initDiscovery()</code> and the <code>BKDiscoveryData</code> contents of the result delegate.
/// You can access the DiscoverySettings by <code>BKClient.discoverySettings</code>
/// Every setting value is writeable and has a default value that is used if not changed by the developer.
SWIFT_CLASS("_TtC10BlukiiInfo19BKDiscoverySettings")
@interface BKDiscoverySettings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Read only data object for Eddystone data that is emitted by beacons
/// See Eddystone specification at https://github.com/google/eddystone/blob/master/protocol-specification.md
/// <code>BKEddystoneData</code> can contain data of unencrypted EddyStone UID, URL and TLM.
/// <code>BKEddystoneData</code> values are part of <code>BKDiscoveryData</code>.
SWIFT_CLASS("_TtC10BlukiiInfo15BKEddystoneData")
@interface BKEddystoneData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Helper class to validate application and mobile device features
SWIFT_CLASS("_TtC10BlukiiInfo18BKFeatureValidator")
@interface BKFeatureValidator : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoBundleOutputData;

/// Read only data object for Info Bundle data retrieved from blukii Manager Info CMS.
/// It contains the results of the <code>BKBlukiiInfo.getInfoBundles(bundleIds:completionHandler:)</code> request to the blukii Manager Info CMS (https://manager.blukii.com).
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoBundleData")
@interface BKInfoBundleData : NSObject <NSCoding>
/// The Bundle Id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The map of bundle output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> Englisch
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this dictionary only contains ouput data of languages that are configured for the Bundle on blukii Manager CMS.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoBundleOutputData *> * _Nonnull outputDataList;
/// If the InfoData items has been marked as protected.
/// true, if protedted
@property (nonatomic, readonly) BOOL itemsProtected;
/// The timestamp of last retrieve from blukii Manager.
/// timestamp in milliseconds
@property (nonatomic, readonly) int64_t timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
@end


/// Read only data object for output language based info bundle data retrieved from blukii Manager Info CMS.
/// It is a child object of  <code>BKInfoBundleData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo22BKInfoBundleOutputData")
@interface BKInfoBundleOutputData : NSObject <NSCoding>
/// The value of the language specific Title.
/// <em>Note:</em> If the language specific field Title is not set title contains the value of field <code>BKInfoBundleData.name</code> (as fallback).
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The url of the Bundles Preview Image.
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class BKInfoOutputData;

/// Read only data object for data of BLE discover and resolving process.
/// It contains the results of the <code>BKBlukiiInfo.getInfoData(blukiiIds:completionHandler:)</code> request to the blukii Manager Info CMS(https://manager.blukii.com).
/// The BKInfoData fields contain the values of one corresponding blukii number.
SWIFT_CLASS("_TtC10BlukiiInfo10BKInfoData")
@interface BKInfoData : NSObject <NSSecureCoding>
/// The Info data id.
///
/// returns:
/// id
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// The blukii Numbers of the Info.
///
/// returns:
/// Blukii Id list
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull blukiiList;
/// The map of Info output data that is referenced by the output language.
/// As map key the following output languages can be used:
/// <ul>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_GERMAN</code> German
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_ENGLISH</code> English
///   </li>
///   <li>
///     <code>BKBlukiiInfo.OUTPUTLANGUAGE_FRENCH</code> French
///   </li>
/// </ul>
/// Please note that this map only contains output data of languages that are configured for the Info on blukii Manager CMS.
///
/// returns:
/// map of ouput data
@property (nonatomic, readonly, copy) NSDictionary<NSString *, BKInfoOutputData *> * _Nonnull outputDataList;
/// The value of the blukii number field Visibility range.
/// This value contains a Bluetooth module defined value for the rssi range in addition to the global rssi setting (@see <code>BKDiscoverySettings.getRssiThreshold()</code>.
/// It does not affect the BLE scan itself but is designed for a better output handling.
///
/// returns:
/// Value of blukii number field Visibility range
@property (nonatomic, readonly) int64_t rssi;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nullable condition;
/// The identifiable name of the Info data.
///
/// returns:
/// Info Data Name
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// :nodoc:
@property (nonatomic, readonly) NSInteger infoProviderId;
/// The timestamp of last retrieve from blukii Manager.
///
/// returns:
/// Timestamp as <code>Date</code>
@property (nonatomic, readonly, copy) NSDate * _Nonnull timeStamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end


/// Read only data object for output language based blukii data retrieved from blukii Manager Info CMS.
/// It is a child object of <code>BKInfoData</code> and contains all data that is language specific
SWIFT_CLASS("_TtC10BlukiiInfo16BKInfoOutputData")
@interface BKInfoOutputData : NSObject <NSCoding>
/// The value of output <em>Title</em>
///
/// returns:
/// Value of Title
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// The value of output <em>URL</em>.
///
/// returns:
/// Value of URL
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// Gets the url of <em>preview Image</em>
///
/// returns:
/// Value of preview url
@property (nonatomic, readonly, copy) NSString * _Nullable previewUrl;
/// The value of the <em>Audio File URL</em>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a url of an audio file.
///
/// returns:
/// Value of Audio File URL of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable urlExtra;
/// The value of  <em>Text to speech</em>.
/// The language is defined by property <code>language</code>.
/// <em>Note:</em> This field is optional and only valid for OutputType <em>PDF</em> (@see <code>outputType</code>). It contains a text.
///
/// returns:
/// Value of Text to speech of Content Type PDF.
@property (nonatomic, readonly, copy) NSString * _Nullable plainTextExtra;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
@end


/// Read only data set for blukii SmartKey
SWIFT_CLASS("_TtC10BlukiiInfo9BKKeyData")
@interface BKKeyData : NSObject <NSSecureCoding>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
@end

@class NSNumber;

/// <h1>Read only data object for iBeacon data that is emitted by beacons</h1>
/// See iBeacon specification at https://developer.apple.com/ibeacon
/// iBeaconData values are part of <code>BKDiscoveryData</code>
SWIFT_CLASS("_TtC10BlukiiInfo13BKiBeaconData")
@interface BKiBeaconData : NSObject <NSSecureCoding>
/// The UUID if the beacon is emitting iBeacon
@property (nonatomic, readonly, copy) NSUUID * _Null_unspecified uuid;
/// The Major ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified major;
/// The Minor ID if the beacon is emitting iBeacon
@property (nonatomic, readonly, strong) NSNumber * _Null_unspecified minor;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif
